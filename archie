#!/bin/bash -e

root_path="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null && pwd )"
cd $root_path

package_stack=()

function archie_clone () {
  if [[ -e packages/$package/git_url ]]
  then
    echo "packages/$package/git_url exists"
    if [[ -d src/$package ]]
    then
      echo "trying to clone into src/$package but it exists!"
      echo "if you really want to re-clone please rm -rf src/$package"
      exit -1
    else
      git_url=`cat packages/$package/git_url`
      echo "running git clone $git_url src/$package"
      if git clone $git_url src/$package
      then
        echo "git clone $git_url succeeded, marking $package clone as not stale"
        rm -f .archie/$package/clone_is_stale
      else
        echo "git clone $git_url failed"
        exit -1
      fi
    fi
  else
    echo "packages/$package/git_url doesn't exist"
    if ls $root_path/packages/$package/*.tar.gz
    then
      tarball=$root_path/packages/$package/*.tar.gz
      echo "$tarball found"
      echo "extracting" $tarball "into tmp"
      mkdir -p .archie/tarball
      cd .archie/tarball
      if tar -x -z -f $tarball
      then
        mkdir -p $root_path/src
        echo "moving" $PWD/*/ "to" $root_path/src/$package/
        rm -rf $root_path/src/$package
        mv */ $root_path/src/$package
        cd $root_path
        echo "tarball clone done, marking $package clone as not stale"
        rm -f .archie/$package/clone_is_stale
      else
        echo "tar failed"
        exit -1
      fi
    else
      echo "no tarballs or git_url found in packages/$package"
      exit -1
    fi
  fi
}

function archie_configure () {
  if [[ -e packages/$package/cmake_configure ]]
  then
    cmake_cmd="cmake "
    if [[ -e $root_path/packages/$package/src_subdir ]]
    then
      subdir=`cat $root_path/packages/$package/src_subdir`
      cmake_cmd+="$root_path/src/$package/$subdir "
    else
      cmake_cmd+="$root_path/src/$package "
    fi
    cmake_cmd+="-DCMAKE_INSTALL_PREFIX=$root_path/install/$package "
    if [[ -e $root_path/packages/$package/depends_on ]]
    then
      depends_on=()
      source $root_path/packages/$package/depends_on
      cmake_prefix_path=""
      for upstream in "${depends_on[@]}"
      do
        upstream_path="$root_path/install/$upstream"
        cmake_prefix_path+=";$upstream_path"
        export ${upstream}_install=$upstream_path
      done
      cmake_cmd+="-DCMAKE_PREFIX_PATH=\"$cmake_prefix_path\" "
    fi
    echo "packages/$package/cmake_configure exists"
    mkdir -p build/$package
    cd build/$package
    echo "sourcing packages/$package/cmake_configure"
    cmake_args=()
    source $root_path/packages/$package/cmake_configure
    cmake_cmd+="${cmake_args[@]} "
    rm -rf CMakeCache.txt CMakeFiles/
    echo "running: $cmake_cmd"
    if eval $cmake_cmd
    then
      cd $root_path
      echo "CMake succeeded for $package, marking config as not stale"
      rm -f .archie/$package/config_is_stale
    else
      echo "CMake failed for $package"
      exit -1
    fi
  else
    echo "packages/$package/cmake_configure doesn't exist"
    exit -1
  fi
}

function archie_install () {
  cd build/$package
  echo "running make install in build/$package"
  if make install -j 4
  then
    cd $root_path
    echo "make install succeeded, marking $package install as not stale"
    rm -f .archie/$package/install_is_stale
  else
    echo "make install of $package failed"
    exit -1
  fi
}

function archie_update_package () {
  if [[ -e .archie/$package/clone_is_stale ]]
  then
    archie_clone
  fi
  if [[ -e .archie/$package/config_is_stale ]]
  then
    archie_configure
  fi
  if [[ -e .archie/$package/install_is_stale ]]
  then
    archie_install
  fi
}

function archie_push () {
  package_stack+=("$package")
}

function archie_pop () {
  package=${package_stack[${#package_stack[@]}-1]}
  unset package_stack[${#package_stack[@]}-1]
}

function archie_local_staleness () {
  archie_clone_staleness
  archie_config_staleness
  archie_local_install_staleness
}

function archie_clone_staleness () {
  if [[ -e .archie/$package/clone_is_stale ]]
  then
    echo "$package clone was already stale"
    return
  fi
  if [[ ! -d src/$package ]]
  then
    echo "$package clone is stale because src/$package doesn't exist"
    touch .archie/$package/clone_is_stale
    return
  fi
}

function archie_config_staleness () {
  if [[ -e .archie/$package/config_is_stale ]]
  then
    echo "$package config was already stale"
    return
  fi
  if [[ ! -d src/$package ]]
  then
    echo "$package config is stale because src/$package doesn't exist"
    touch .archie/$package/config_is_stale
    return
  fi
  if [[ ! -d build/$package ]]
  then
    echo "$package config is stale because build/$package doesn't exist"
    touch .archie/$package/config_is_stale
    return
  fi
}

function archie_local_install_staleness () {
  if [[ -e .archie/$package/install_is_stale ]]
  then
    echo "$package install was already stale"
    return
  fi
  if [[ -e .archie/$package/clone_is_stale ]]
  then
    echo "$package install is stale because $package clone is stale"
    touch .archie/$package/install_is_stale
    return
  fi
  if [[ -e .archie/$package/config_is_stale ]]
  then
    echo "$package install is stale because $package config is stale"
    touch .archie/$package/install_is_stale
    return
  fi
}

function archie_depended_on_by () {
  echo "determining depended_on_by"
  for package_path in packages/*/
  do
    package=`basename $package_path`
    mkdir -p .archie/$package
    rm -f .archie/$package/depended_on_by
  done
  for package_path in packages/*/
  do
    if [[ -e $package_path/depends_on ]]
    then
      package=`basename $package_path`
      depends_on=()
      source $package_path/depends_on
      for upstream in ${depends_on[@]}
      do
        echo $package >> .archie/$upstream/depended_on_by
      done
    fi
  done
}

function archie_global_staleness_dfs () {
  touch .archie/$package/visited
  if [[ -e .archie/$package/depended_on_by ]]
  then
    for downstream in `cat .archie/$package/depended_on_by`
    do
      if [[ ! -e .archie/$downstream/visited ]]
      then
        if [[ -e .archie/$package/install_is_stale ]] && [[ ! -e .archie/$downstream/install_is_stale ]]
        then
          echo "marked $downstream install as stale because $package install was stale"
          touch .archie/$downstream/install_is_stale
        fi
        archie_push
        package=$downstream
        archie_global_staleness_dfs
        archie_pop
      fi
    done
  fi
}

function archie_global_staleness () {
  for package_path in packages/*/
  do
    package=`basename $package_path`
    mkdir -p .archie/$package
    archie_local_staleness
    rm -f .archie/$package/visited
  done
  for package_path in packages/*/
  do
    package=`basename $package_path`
    if [[ ! -e .archie/$package/visited ]]
    then
      depends_on=()
      if [[ -e $package_path/depends_on ]]
      then
        source $package_path/depends_on
      fi
      if [ ${#depends_on[@]} -eq 0 ]
      then
        package=`basename $package_path`
        archie_global_staleness_dfs
      fi
    fi
  done
}

function archie_update_dfs () {
  archie_update_package
  touch .archie/$package/visited
  if [[ -e .archie/$package/depended_on_by ]]
  then
    for downstream in `cat .archie/$package/depended_on_by`
    do
      if [[ ! -e .archie/$downstream/visited ]]
      then
        archie_push
        package=$downstream
        archie_update_dfs
        archie_pop
      fi
    done
  fi
}

function archie_global_update () {
  for package_path in packages/*/
  do
    package=`basename $package_path`
    rm -f .archie/$package/visited
  done
  for package_path in packages/*/
  do
    package=`basename $package_path`
    if [[ ! -e .archie/$package/visited ]]
    then
      depends_on=()
      if [[ -e $package_path/depends_on ]]
      then
        source $package_path/depends_on
      fi
      if [ ${#depends_on[@]} -eq 0 ]
      then
        package=`basename $package_path`
        archie_update_dfs
      fi
    fi
  done
}

function archie_update () {
  archie_depended_on_by
  archie_global_staleness
  archie_global_update
}

function assert_package () {
  if [[ ! -d packages/$package ]]
  then
    echo "packages/$package doesn't exist so $package isn't a package"
    exit -1
  fi
}

function archie_changed_src () {
  package=`basename $1`
  assert_package
  echo "marking $package's install as stale per user request"
  touch .archie/$package/install_is_stale
}

function archie_changed_config () {
  dir=`dirname $1`
  package=`basename $dir`
  assert_package
  echo "marking $package's config as stale per user request"
  touch .archie/$package/config_is_stale
}

function archie_changed_clone () {
  dir=`dirname $1`
  package=`basename $dir`
  assert_package
  echo "marking $package's clone as stale per user request"
  touch .archie/$package/clone_is_stale
}

function archie_changed () {
  if [ -z $1 ]
  then
    echo "no argument to archie changed, syntax is:"
    echo "  archie changed <path>"
    echo "examples:"
    echo "  archie changed src/mypackage"
    exit -1
  fi
  case "$1" in
    src/*)
      archie_changed_src $1
      ;;
    packages/*/cmake_configure)
      archie_changed_config $1
      ;;
    packages/*/*.tar.gz)
      archie_changed_clone $1
      ;;
    packages/*/git_url)
      archie_changed_clone $1
      ;;
    archie)
      # do nothing if this script itself changed
      ;;
    *)
      echo "$1 is not a recognized path in the archie tree"
      exit -1
      ;;
  esac
}

function archie_pull_src () {
  package=`basename $1`
  assert_package
  cd src/$package
  git pull &> $root_path/.archie/pull_output
  if [[ $? == 0 ]]
  then
    echo "git pull in src/$package succeeded"
    if cat $root_path/.archie/pull_output | grep -q 'Already up-to-date.'
    then
      echo "src/$package was already up-to-date"
    else
      echo "src/$package modified by git pull"
      echo "marking $package's install as stale per user request"
      touch .archie/$package/install_is_stale
    fi
    cd $root_path
  else
    echo "git pull in src/$package failed"
    echo "output was:"
    cat $root_path/.archie/pull_output
    exit -1
  fi
}

function archie_pull_self () {
  if git fetch
  then
    echo "git fetch succeeded"
  else
    echo "git fetch failed"
    exit -1
  fi
  git diff --name-status HEAD..FETCH_HEAD | grep -v "^D" | cut -f 2 > .archie/pull_diff
  if git merge FETCH_HEAD
  then
    echo "git merge FETCH_HEAD succeeded"
    for path in `cat .archie/pull_diff`
    do
      archie_changed $path
    done
  else
    echo "git merge FETCH_HEAD failed"
  fi
}

function archie_pull () {
  if [ -z $1 ]
  then
    echo "no argument to archie pull, syntax is:"
    echo "  archie pull <path>"
    echo "examples:"
    echo "  archie pull src/mypackage"
    exit -1
  fi
  case "$1" in
    src/*)
      archie_pull_src $1
      ;;
    self)
      archie_pull_self
      ;;
    *)
      echo "$1 is not a recognized pull argument"
      exit -1
      ;;
  esac
}

if [ -z "$1" ]
then
  echo "no command given"
  echo "available commands are:"
  echo "  update"
  echo "ensure all packages are built up-to-date with external changes"
  echo "  changed src/<pkg>"
  echo "update assuming <pkg> source changed"
  echo "  changed packages/<pkg>/cmake_configure"
  echo "update assuming <pkg> CMake options logic changed"
  echo "  changed packages/<pkg>/git_url"
  echo "update assuming <pkg> origin URL changed"
  echo "  changed packages/<pkg>/*.tar.gz"
  echo "update assuming <pkg> tarball contents changed"
  exit
fi

case $1 in
  update)
    echo "executing update command"
    archie_update
    ;;
  changed)
    echo "executing changed $2 command"
    archie_changed $2
    archie_update
    ;;
  pull)
    echo "executing pull $2 command"
    archie_pull $2
    archie_update
    ;;
  *)
    echo "don't recognize command $1!"
    exit -1
    ;;
esac
